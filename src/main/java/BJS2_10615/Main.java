package BJS2_10615;

import java.util.*;
import java.util.stream.Stream;

/*
На вход дан список целых чисел и число. Найдите все уникальные пары чисел, сумма которых равна заданному числу.

На вход получаем мапу с названиями стран и их столицами. Отсортируйте страны по алфавиту, а затем выведите названия их столиц в виде списка.

Получаем список строк и букву в виде char. Отфильтруйте строки, которые начинаются с заданной буквы, и отсортируйте их по длине в порядке возрастания, и верните список этих строк.

Дана мапа, где ключами являются имена людей, а значениями — списки их друзей. Найдите все пары людей, которые не являются друзьями, но у них есть общие друзья.

Получаем список объектов класса Employee, у каждого из которых есть имя, зарплата и отдел. Найдите среднюю зарплату для каждого отдела. Должна получится map с именем отдела и средней зарплатой.

Дан список строк. Отфильтруйте строки, которые содержат только буквы заданного алфавита, и отсортируйте их в порядке возрастания длины строк.

Написать метод, который преобразует список целых чисел в список строк, где каждое число записано в двоичном виде.

Написать метод, который найдет все числа-палиндромы (читающиеся одинаково слева направо и справа налево) в заданном диапазоне. На вход получаем число для начала диапазона и число для второй границы диапазона.

Доп задание: Написать метод, который найдёт все подстроки в строке, которые являются палиндромами. На вход получаем строку, а вернуть должны список строк.

Доп задание: Написать метод, который найдёт все совершенные числа (сумма делителей числа равна самому числу) в заданном диапазоне. На вход получаем число для начала диапазона и число для второй границы диапазона.
 */

//На вход дан список целых чисел и число. Найдите все уникальные пары чисел, сумма которых равна заданному числу.
public class Main {
    public static List<int[]> sumUnique(List<Integer> nums, int number) {
        Set<Integer> usePair = new HashSet<>();
        List<int[]> pairs = new ArrayList<>();
        nums.stream().distinct().forEach(num -> {
            int target = number - num;
            if (nums.contains(target) && !usePair.contains(target)) {
                usePair.add(target);
                pairs.add(new int[]{num, target});
            }
        });
        return pairs;
    }
    public static List<String> sortedCounty(Map<String,String> countriesAndCapital) {
        return countriesAndCapital.entrySet().stream().sorted()

    }
}
