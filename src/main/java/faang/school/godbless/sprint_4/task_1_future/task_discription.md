# Асинхронность и Future

## Условия задачи
Представьте, что вы работаете в **Stripe** и интегрируетесь с каким-нибудь внешним сервисом приема платежей. Например, `MasterCard`.

1. Создайте экземпляр класса `MasterCardService`, у которого есть методы `int collectPayment()` и `int sendAnalytics()`.

2. Реализуйте метод `doAll`, который:
   * Вызывает метод `collectPayment` параллельно, и получает `Future`;
   * Вызывает метод `sendAnalytics` параллельно, и получает `CompletableFuture`;  

Сначала ожидает завершения `sendAnalytics` и выводит результат. Кто ожидает? Поток, который и запустил задачу, 
т.е. основной поток, в котором и выполняется метод `doAll`, но никаких ожиданий через `Thread.sleep`! 
Нужно “присоединиться” к тому потоку, завершения которого ждём. Какой метод может помочь?

Потом дожидается `collectPayment` и выводит результат.

3. Содержимое `collectPayment` и `sendAnalytics` может быть следующим:

```java
static int collectPayment() {
    try {
        Thread.sleep(10_000);
        return 10_000;
    } catch (InterruptedException e) {
        e.printStackTrace();
        throw new RuntimeException();
    }
}

static int sendAnalystics() {
    try {
        Thread.sleep(1_000);
        return 1_000;
    } catch (InterruptedException e) {
        e.printStackTrace();
        throw new RuntimeException();
    }
}
```

## Почему эта задача полезна?
Эта задача полезна с точки зрения изучения асинхронности, многопоточности и `Future` в `Java`, так как она демонстрирует, 
как можно использовать `CompletableFuture` и `Future` для выполнения асинхронных задач и получения результатов независимо друг от друга.

В результате мы сможем отправлять аналитику в сервис сбора платежей прямо во время того, как платеж происходит. 
Возможно, это не аналитика по результатам платежа, а аналитика того, что клиент вообще ХОТЕЛ сделать платеж. 
Это очень важный показатель в бизнесе. Даже если в результате он не смог по какой-то причине его завершить.


