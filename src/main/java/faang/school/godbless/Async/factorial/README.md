Техлид проверит эту задачу в свободное время (долгое ревью).

Итак, нам дали задание: вычислить факториалы списка чисел. Представим, что мы не знаем, 
как использовать мемоизацию (динамическое программирование) для того, 
чтобы многократно и быстро вычислять факториалы числа, 
поэтому решили оптимизировать задачу с использованием многопоточности

Если что, факториал это:

N! = 1 * 2 * 3 ... * (N - 1) * N
Так, например:

1! = 1
2! = 1 * 2 = 2
3! = 1 * 2 * 3 = 6
5! = 1 * 2 * 3 * 4 * 5 = 120
1. Вам дан класс Factorialследующего вида:

public class Factorial {
private static final int MAX_INT_FACTORIAL = 12;
private static final int MAX_LONG_FACTORIAL = 19;
}
2. Для начала, реализуйте в нём 3 статических метода со следующими сигнатурами:

static int factorialInt(int n) throws IllegalArgumentException;

static long factorialLong(int n) throws IllegalArgumentException;

static BigInteger factorialBig(int n);
Тут предполагается:

factorialInt справляется со значениями n от 0 до MAX_INT_FACTORIAL включительно, 
иначе IllegalArgumentException;

factorialLong справляется со значениями n от MAX_INT_FACTORIAL 
+ 1 до MAX_LONG_FACTORIAL включительно, иначе IllegalArgumentException;

factorialBig справляется со значениями n бОльшими чем MAX_LONG_FACTORIAL.

Т.е.

factorialLong использует внутри себя factorialInt для вычисления факториала числа до MAX_INT_FACTORIAL;

factorialBig использует внутри себя factorialLong для вычисления факториала числа до MAX_LONG_FACTORIAL;

Почему так? Потому что если мы вычислим факториал числа 13 в 
рамках типа int, то ответ переполнится и не влезет в 32-битную сетку int. 
Также факториал 21-го для long тоже переполнится и не влезет в 64-битную сетку. 
В таких случаях мы используем BigInteger для целых чисел.

Почему же мы не будем сразу вычислять для BigInteger, скажете вы. 
Тут мы хотим максимально оптимизировать время работы алгоритма, 
выполнять арифметические операции с int или long намного быстрее 
и дешевле нежели с BigInteger

3. Напишите статический метод, который вычислит факториалы для списка чисел:

- List<CompletableFuture<BigInteger>> factorials(List<Integer> numbers);
- Ответ сразу возвращаем в BigInteger, 
даже если он влезает в int или long. 
Обратите внимание, что результат функции 
factorials является списком CompletableFuture, 
т.е. мы должны не блокироваться внутри этого метода, 
а должны асинхронно выполнить каждую задачу, и вернуть только Future, 
как только назначили задачи на выполнение.

4. В методе main класса Factorial напишите код, 
который вызовет метод factorials со списком

// Можете поменять на свой, добавить больше чисел, или сделать их больше
List<Integer> numbers = List.of(
50, 100, 200, 300, 400, 10, 25, 10000
);
List<CompletableFuture<BigInteger>> result = factorials(numbers);
5. Далее, т.к. каждая задача выполняется асинхронно 
мы должны уметь получать результат каждой из них независимо. 
Будет странно, если мы сначала дождемся 1-го числа, а потом уже пойдём проверять последующие. 
Мы должны вывести результат, как только он пришёл,
поэтому давайте создадим для каждого CompletableFuture поток, 
и будем в нём ожидать значение оттуда. Выводим результат в консоль, как только дождались ответа.

Вам нужно написать свой код в методе mainвместо ???. 
Переменная counter нужна для того, что бы определить, 
что все задачи были успешно выполнены и мы дождались их результата. 
Подумайте, какой тип данных лучше использовать для этого. 
В конце мы будем ждать выполнения всех задач в цикле while, 
и будем считать там awaitCounter, сколько же мы итераций 
провели до выполнения всех задач?

List<Integer> numbers = List.of(
50, 100, 200, 300, 400, 10, 25, 10000
);
List<CompletableFuture<BigInteger>> result = factorials(numbers);
??? counter = new ???;
for (int i = 0; i < result.size(); ++i) {
new Thread(
() -> {
???
}
).start();
}

int awaitCounter = 0;
while (counter.get() != numbers.size()) {
awaitCounter++;
}
System.out.println("Awaited all asynchronous tasks, counter = " + awaitCounter);
Почему эта задача полезна?
Эта задача полезна с точки зрения изучения асинхронности,
многопоточности и Futureв Java, так как она демонстрирует, 
как можно использовать CompletableFutureдля выполнения асинхронных
задач и получения результатов независимо друг от друга.
Также в задаче используется создание отдельных потоков
для ожидания результатов каждой задачи, что позволяет избежать 
блокирования основного потока программы. В целом, эта задача помогает
понять, как работать с асинхронными задачами в Java и как использовать 
CompletableFutureдля их выполнения и получения результатов