Условия задачи
Описание: Вы являетесь разработчиком приложения Google Translator и работаете над функцией, которая позволяет
пользователям добавлять слова и их переводы в словарь. Вам необходимо создать систему, которая будет принимать слово и его перевод, а затем сохранять их в словарь с использованием интерфейса BiConsumer.

Цель: Создайте класс DictionaryProcessor, который будет использовать BiConsumer для обработки словаря.

Требования:

Создайте класс DictionaryProcessor с методом processWord;

Метод processWord должен принимать слово, его перевод и BiConsumer для обработки словаря;

Создайте лямбда-выражение для сохранения слова и его перевода в словарь, используя интерфейс BiConsumer;

Протестируйте вашу систему, создав несколько примеров слов и их переводов.

Пример использования:

DictionaryProcessor dictionaryProcessor = new DictionaryProcessor();

// Создание словаря
Map<String, String> dictionary = new HashMap<>();

// Создание BiConsumer для сохранения слова и его перевода в словарь
BiConsumer<String, String> addWordToDictionary = (word, translation) -> dictionary.put(word, translation);

// Добавление слов и их переводов
dictionaryProcessor.processWord("привет", "hello", addWordToDictionary);
dictionaryProcessor.processWord("мир", "world", addWordToDictionary);
dictionaryProcessor.processWord("программирование", "programming", addWordToDictionary);

System.out.println("Словарь: " + dictionary);
Почему эта задача полезна?
Обратите внимание, что в примере Map создаётся вне объекта DictionaryProcessor. Т.е. DictionaryProcessor ничего не знает
про эту коллекцию! Он в принципе просто выполняет какие-то действия.

А вот Map используется уже внутри лямбды. Как это называется? Замыкание! Это когда внутри функции используются
переменные созданные извне.

И посмотрите, что теперь можно делать: внутри функции мы замкнули мапу, а потом эту функцию уже передаем внутрь
DictionaryProcessor. В результате функция сохраняет доступ к внешней мапе и знает, куда всё ещё нужно складывать слова

Подсказки
BiConsumer — это то же самое, что и Consumer в Java. Тоже функциональный интерфейс, но разница лишь в том, что его метод
accept принимает не один параметр, а два. Вот и всё!