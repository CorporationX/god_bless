`# Очередь в Walmart (Дополнительно)

## Условия задачи

У **Walmart** есть несколько касс, каждая из которых обслуживает покупателей. Каждый кассир — это отдельный поток. 
Напишите программу, которая использует наследование от класса `Thread`, чтобы создать классы, представляющие кассы в 
**Walmart**.

Когда покупатель приходит в **Walmart**, он выбирает случайную кассу и становится в очередь. 
Покупатель ждёт, пока кассир закончит обслуживание текущего покупателя, и только после этого начинает обслуживаться сам.

1. Создайте класс `CashierThread`, который наследуется от класса `Thread`.

2. В классе `CashierThread` объявите поля: 
   * `cashierId` (идентификатор кассира)
   * `customerItems` (массив товаров покупателя). 

3. Создайте конструктор для класса `CashierThread`.

4. В методе `run()` класса `CashierThread` реализуйте логику обработки товаров покупателя кассиром.

5. В методе `main()` создайте двумерный массив `customers`, где каждый элемент массива представляет список товаров для 
каждого покупателя.

6. Создайте массив `cashiers` для хранения потоков кассиров. Каждый элемент массива `cashiers` должен соответствовать 
одному покупателю из массива `customers`.

7. В цикле `for` создайте объекты класса `CashierThread` и добавьте их в массив `cashiers`.

8. В цикле `for` запустите все потоки кассиров из массива `cashiers` с помощью метода `start()`.

9. После выполнения всех потоков кассиров в методе `run()` каждого потока, выведете на экран информацию о количестве 
обработанных товаров и общей стоимости.

## Почему эта задача полезна?
Ситуацию из этой задачи можно перенести на работу приложения с сетевыми соединениями. 
Ваше приложение может создавать отдельный поток для каждого клиента, чтобы обрабатывать его запросы и сообщения. 
Например, **Apache Tomcat** — популярный веб-сервер и контейнер сервлетов, который использует потоки `Thread` для обработки 
входящих запросов от клиентов. Также многие фреймворки для создания сетевых приложений, такие как **Netty** и **Jetty**, 
используют подобный подход.`