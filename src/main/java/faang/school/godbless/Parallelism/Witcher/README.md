Ведьмак Геральт должен путешествовать по различным городам и убивать монстров. 
Для этого он использует магическую карту, которая позволяет определять 
оптимальный маршрут между городами и наименьшее количество времени, 
затраченного на путешествия.

Давайте посмотрим, как работает эта магическая карта!

1. Создать класс Monster, который будет содержать информацию о монстрах: 
имя и местоположение. Добавить конструктор и геттеры.

2. Создать класс City, который будет содержать информацию о городах: 
имя, местоположение (класс Location c полями-координатами x, y) 
и расстояние от местоположения ведьмака до каждого города. 
По умолчанию Геральт находится в Каэр Морхене. Конструктор и геттеры.

3. Создать класс CityWorker, который будет реализовывать интерфейс Runnable 
и содержать логику обработки одного города:

- поиск ближайшего монстра (public Monster findNearestMonster(City city, List<Monster> monsters)). 
Чтобы найти ближайшего монстра, можно посчитать разницу между положением 
города и положением каждого монстра;

- расчёт времени на убийство монстра (public long getKillTime()). 
Пока Геральт убивает монстра, мы ждем;

- дальность путешествия (public long getJourneyDistance()). 
Геральт находится там, где дистанция между ним и городом равна 0. 
По умолчанию Геральт находится в Каэр Морхене. Чтобы определить, 
как долго Геральту идти, нужно посчитать разницу дистанций.

Если вам кажется, что здесь можно добавить какие-то дополнительные параметры 
— тоже можете добавить. Это время проявить творчество!

4. Создать класс Witcher, который будет содержать метод main 
и служить точкой входа в программу. В методе main нужно создать 
список городов и монстров (примеры приведены ниже), 
создать ExecutorService с фиксированным числом потоков и запустить 
работу потоков на обработку каждого города в отдельности. 
После завершения работы всех потоков нужно вычислить общее время, 
затраченное на выполнение программы.

5. В методе main можно изменять параметр NUM_THREADS и количество городов 
и монстров в списках, чтобы сравнить время выполнения программы в однопоточном 
и многопоточном режимах. Это главное условие задачи. Посмотрите, 
будет ли программа выполняться быстрее в один поток, чем в несколько.

6. Запустить программу и проанализировать результаты.

Примеры заполнения списков:


    List<Monster> monsters = new ArrayList<>();
    
    monsters.add(new Monster("Griffin", "Velen"));
    monsters.add(new Monster("Basilisk", "Toussaint"));
    monsters.add(new Monster("Cockatrice", "White Orchard"));
    monsters.add(new Monster("Chort", "Skellige"));
    
   
 
    List<City> cities = new ArrayList<>();
    
    cities.add(new City("Novigrad", new Location(0, 60),  180));
    cities.add(new City("Oxenfurt", new Location(60, 0), 70));
    cities.add(new City("Vizima", new Location(120, 50), 30));
    cities.add(new City("Kaer Morhen", new Location(180, 70), 0));

Почему эта задача полезна?
Например, SpaceX используют симуляции для оптимизации дизайна ракет 
и ускорения процесса разработки. Симуляции, используемые в процессе оптимизации дизайна, 
могут потребовать высокой вычислительной мощности и использования 
параллельной обработки данных.

Разработчики таких систем должны точно понимать, 
в каких ситуациях многопоточный подход поможет решить стоящие 
перед ними проблемы, а в каких только замедлит работу!