Условия задачи
Итак, нам дали задание: вычислить факториалы списка чисел. Представим, что мы не знаем,
как использовать мемоизацию (динамическое программирование) для того, чтобы многократно
и быстро вычислять факториалы числа, поэтому решили оптимизировать задачу с использованием
многопоточности

Если что, факториал это:

N! = 1 * 2 * 3 ... * (N - 1) * N
Так, например:

1! = 1
2! = 1 * 2 = 2
3! = 1 * 2 * 3 = 6
5! = 1 * 2 * 3 * 4 * 5 = 120
1. Вам дан класс Factorial следующего вида:

public class Factorial {
    private static final int MAX_INT_FACTORIAL = 12;
    private static final int MAX_LONG_FACTORIAL = 19;
}
2. Для начала, реализуйте в нём 3 статических метода со следующими сигнатурами:

static int factorialInt(int n) throws IllegalArgumentException;

static long factorialLong(int n) throws IllegalArgumentException;

static BigInteger factorialBig(int n);
Тут предполагается:

factorialInt справляется со значениями n от 0 до MAX_INT_FACTORIAL включительно,
иначе IllegalArgumentException;

factorialLong справляется со значениями n от MAX_INT_FACTORIAL + 1 до MAX_LONG_FACTORIAL
включительно, иначе IllegalArgumentException;

factorialBig справляется со значениями n бОльшими чем MAX_LONG_FACTORIAL.

Т.е.

factorialLong использует внутри себя factorialInt для вычисления факториала
числа до MAX_INT_FACTORIAL;

factorialBig использует внутри себя factorialLong для вычисления факториала
числа до MAX_LONG_FACTORIAL;

Почему так? Потому что если мы вычислим факториал числа 13 в рамках типа int,
то ответ переполнится и не влезет в 32-битную сетку int. Также факториал 21-го
для long тоже переполнится и не влезет в 64-битную сетку. В таких случаях мы
используем BigInteger для целых чисел.

Почему же мы не будем сразу вычислять для BigInteger, скажете вы.
Тут мы хотим максимально оптимизировать время работы алгоритма,
выполнять арифметические операции с int или long намного быстрее и
дешевле нежели с BigInteger

3. Напишите статический метод, который вычислит факториалы для списка чисел:

List<CompletableFuture<BigInteger>> factorials(List<Integer> numbers);
Ответ сразу возвращаем в BigInteger, даже если он влезает в int или long.
Обратите внимание, что результат функции factorials является списком CompletableFuture,
т.е. мы должны не блокироваться внутри этого метода, а должны асинхронно выполнить
каждую задачу, и вернуть только Future, как только назначили задачи на выполнение.

4. В методе main класса Factorial напишите код, который вызовет метод factorials со списком

// Можете поменять на свой, добавить больше чисел, или сделать их больше
List<Integer> numbers = List.of(
        50, 100, 200, 300, 400, 10, 25, 10000
);
List<CompletableFuture<BigInteger>> result = factorials(numbers);
5. Далее, т.к. каждая задача выполняется асинхронно мы должны уметь получать
результат каждой из них независимо. Будет странно, если мы сначала дождемся 1-го числа,
а потом уже пойдём проверять последующие. Мы должны вывести результат, как только он пришёл,
поэтому давайте создадим для каждого CompletableFuture поток, и будем в нём ожидать
значение оттуда. Выводим результат в консоль, как только дождались ответа.

Вам нужно написать свой код в методе mainвместо ???. Переменная counter нужна для того,
что бы определить, что все задачи были успешно выполнены и мы дождались их результата.
Подумайте, какой тип данных лучше использовать для этого. В конце мы будем ждать
выполнения всех задач в цикле while, и будем считать там awaitCounter, сколько же
мы итераций провели до выполнения всех задач?

List<Integer> numbers = List.of(
        50, 100, 200, 300, 400, 10, 25, 10000
);
List<CompletableFuture<BigInteger>> result = factorials(numbers);
??? counter = new ???;
for (int i = 0; i < result.size(); ++i) {
    new Thread(
            () -> {
									???
            }
    ).start();
}

int awaitCounter = 0;
while (counter.get() != numbers.size()) {
    awaitCounter++;
}
System.out.println("Awaited all asynchronous tasks, counter = " + awaitCounter);